/* eslint-disable */
/* tslint:disable */
// @ts-nocheck
/* prettier-ignore-start */

/** @jsxRuntime classic */
/** @jsx createPlasmicElementProxy */
/** @jsxFrag React.Fragment */

// This class is auto-generated by Plasmic; please do not edit!
// Plasmic Project: f7DE9y7qp46fyCw5nuY8f9
// Component: 3Nv859pBep3Y

import * as React from "react";

import Head from "next/head";
import Link, { LinkProps } from "next/link";
import { useRouter } from "next/router";

import {
  Flex as Flex__,
  MultiChoiceArg,
  PlasmicDataSourceContextProvider as PlasmicDataSourceContextProvider__,
  PlasmicIcon as PlasmicIcon__,
  PlasmicImg as PlasmicImg__,
  PlasmicLink as PlasmicLink__,
  PlasmicPageGuard as PlasmicPageGuard__,
  SingleBooleanChoiceArg,
  SingleChoiceArg,
  Stack as Stack__,
  StrictProps,
  Trans as Trans__,
  classNames,
  createPlasmicElementProxy,
  deriveRenderOpts,
  ensureGlobalVariants,
  generateOnMutateForSpec,
  generateStateOnChangeProp,
  generateStateOnChangePropForCodeComponents,
  generateStateValueProp,
  get as $stateGet,
  hasVariant,
  initializeCodeComponentStates,
  initializePlasmicStates,
  makeFragment,
  omit,
  pick,
  renderPlasmicSlot,
  set as $stateSet,
  useCurrentUser,
  useDollarState,
  usePlasmicTranslator,
  useTrigger,
  wrapWithClassName
} from "@plasmicapp/react-web";
import {
  DataCtxReader as DataCtxReader__,
  useDataEnv,
  useGlobalActions
} from "@plasmicapp/react-web/lib/host";

import { usePlasmicDataSourceContext } from "@plasmicapp/data-sources-context";
import {
  executePlasmicDataOp,
  usePlasmicDataOp,
  usePlasmicInvalidate
} from "@plasmicapp/react-web/lib/data-sources";

import { PageLoader } from "../../others/PageLoader/PageLoader"; // plasmic-import: FHDrnDhA4DZe/codeComponent
import { SmartLoader } from "../../others/SmartLoader/SmartLoader"; // plasmic-import: YAp2GWWLB3S2/codeComponent
import { FormWrapper } from "@plasmicpkgs/antd5/skinny/Form";
import { formHelpers as FormWrapper_Helpers } from "@plasmicpkgs/antd5/skinny/Form";
import { FormItemWrapper } from "@plasmicpkgs/antd5/skinny/FormItem";
import { AntdInput } from "@plasmicpkgs/antd5/skinny/registerInput";
import { inputHelpers as AntdInput_Helpers } from "@plasmicpkgs/antd5/skinny/registerInput";
import { AntdTextArea } from "@plasmicpkgs/antd5/skinny/registerInput";
import { inputHelpers as AntdTextArea_Helpers } from "@plasmicpkgs/antd5/skinny/registerInput";
import Button from "../../Button"; // plasmic-import: 9ixtKbGKv7x-/component
import { UploadWrapper } from "@plasmicpkgs/antd5/skinny/registerUpload";
import TextInput from "../../TextInput"; // plasmic-import: pZ7Ql6sUFRw9/component
import Select from "../../Select"; // plasmic-import: ZMB-SB-xJDyQ/component
import MenuItem from "../../MenuItem"; // plasmic-import: plmAgyhhAdMc/component
import { AntdSelect } from "@plasmicpkgs/antd5/skinny/registerSelect";
import ProductCard from "../../ProductCard"; // plasmic-import: XNMQC2V0FBMZ/component
import { AlertManager } from "../../alerts/AlertManager/AlertManager"; // plasmic-import: vWsoh6ymTswC/codeComponent
import ProgressBar from "../../ProgressBar"; // plasmic-import: o2sDSKJQp4UX/component
import { Fetcher } from "@plasmicapp/react-web/lib/data-sources";

import "@plasmicapp/react-web/lib/plasmic.css";

import plasmic_antd_5_hostless_css from "../antd_5_hostless/plasmic.module.css"; // plasmic-import: ohDidvG9XsCeFumugENU3J/projectcss
import plasmic_library_tailwind_3_4_number_tokens_css from "../library_tailwind_3_4_number_tokens/plasmic.module.css"; // plasmic-import: 4vjRXvnb4XuY6J15w9oRcQ/projectcss
import plasmic_plasmic_rich_components_css from "../plasmic_rich_components/plasmic.module.css"; // plasmic-import: jkU633o1Cz7HrJdwdxhVHk/projectcss
import projectcss from "./plasmic.module.css"; // plasmic-import: f7DE9y7qp46fyCw5nuY8f9/projectcss
import sty from "./PlasmicOnboarding.module.css"; // plasmic-import: 3Nv859pBep3Y/css

import Icon10Icon from "./icons/PlasmicIcon__Icon10"; // plasmic-import: 0QBsBx5rQ6RM/icon
import CircleIcon from "./icons/PlasmicIcon__Circle"; // plasmic-import: je95h6YoQ2jE/icon
import GroupIcon from "./icons/PlasmicIcon__Group"; // plasmic-import: yIYn4o5HgDaM/icon
import PhPencilSimpleIcon from "./icons/PlasmicIcon__PhPencilSimple"; // plasmic-import: 7xHLZEkolpKE/icon
import PhTrashIcon from "./icons/PlasmicIcon__PhTrash"; // plasmic-import: juO39VElEpcx/icon
import Icon12Icon from "./icons/PlasmicIcon__Icon12"; // plasmic-import: QOMO9U8NfL6f/icon

createPlasmicElementProxy;

export type PlasmicOnboarding__VariantMembers = {};
export type PlasmicOnboarding__VariantsArgs = {};
type VariantPropType = keyof PlasmicOnboarding__VariantsArgs;
export const PlasmicOnboarding__VariantProps = new Array<VariantPropType>();

export type PlasmicOnboarding__ArgsType = {
  step?: number;
  onStepChange?: (val: string) => void;
  children?: React.ReactNode;
  step3?: number;
};
type ArgPropType = keyof PlasmicOnboarding__ArgsType;
export const PlasmicOnboarding__ArgProps = new Array<ArgPropType>(
  "step",
  "onStepChange",
  "children",
  "step3"
);

export type PlasmicOnboarding__OverridesType = {
  root?: Flex__<"div">;
};

export interface DefaultOnboardingProps {
  step?: number;
  onStepChange?: (val: string) => void;
  children?: React.ReactNode;
  step3?: number;
  className?: string;
}

const $$ = {};

function useNextRouter() {
  try {
    return useRouter();
  } catch {}
  return undefined;
}

function PlasmicOnboarding__RenderFunc(props: {
  variants: PlasmicOnboarding__VariantsArgs;
  args: PlasmicOnboarding__ArgsType;
  overrides: PlasmicOnboarding__OverridesType;
  forNode?: string;
}) {
  const { variants, overrides, forNode } = props;

  const args = React.useMemo(
    () =>
      Object.assign(
        {
          step3: 0
        },
        Object.fromEntries(
          Object.entries(props.args).filter(([_, v]) => v !== undefined)
        )
      ),
    [props.args]
  );

  const $props = {
    ...args,
    ...variants
  };

  const __nextRouter = useNextRouter();

  const $ctx = useDataEnv?.() || {};
  const refsRef = React.useRef({});
  const $refs = refsRef.current;

  let [$queries, setDollarQueries] = React.useState<
    Record<string, ReturnType<typeof usePlasmicDataOp>>
  >({});
  const stateSpecs: Parameters<typeof useDollarState>[0] = React.useMemo(
    () => [
      {
        path: "step",
        type: "writable",
        variableType: "number",

        valueProp: "step",
        onChangeProp: "onStepChange"
      },
      {
        path: "productId",
        type: "private",
        variableType: "text",
        initFunc: ({ $props, $state, $queries, $ctx }) => "prod_S81KBWHPyJa53z"
      },
      {
        path: "stripeSessionId",
        type: "private",
        variableType: "text",
        initFunc: ({ $props, $state, $queries, $ctx }) =>
          "cs_test_a1OndaBFWbGXTkTWhBWzrUXROUQWoUIf36yo4jdSBAcp0KPHMDcss5lBab"
      },
      {
        path: "createAccount",
        type: "private",
        variableType: "boolean",
        initFunc: ({ $props, $state, $queries, $ctx }) => false
      },
      {
        path: "priceId",
        type: "private",
        variableType: "text",
        initFunc: ({ $props, $state, $queries, $ctx }) =>
          "price_1RDlIQG6x7PbBmxr3DLXR9uL"
      },
      {
        path: "customerId",
        type: "private",
        variableType: "text",
        initFunc: ({ $props, $state, $queries, $ctx }) => ""
      },
      {
        path: "stripeStatus",
        type: "private",
        variableType: "text",
        initFunc: ({ $props, $state, $queries, $ctx }) => ""
      },
      {
        path: "stripeSubscriptionId",
        type: "private",
        variableType: "text",
        initFunc: ({ $props, $state, $queries, $ctx }) => ""
      },
      {
        path: "variable",
        type: "private",
        variableType: "text",
        initFunc: ({ $props, $state, $queries, $ctx }) => ""
      }
    ],
    [$props, $ctx, $refs]
  );
  const $state = useDollarState(stateSpecs, {
    $props,
    $ctx,
    $queries: $queries,
    $refs
  });
  const dataSourcesCtx = usePlasmicDataSourceContext();
  const plasmicInvalidate = usePlasmicInvalidate();

  const new$Queries: Record<string, ReturnType<typeof usePlasmicDataOp>> = {
    stripeProductsList: usePlasmicDataOp(() => {
      return {
        sourceId: "iWyefF3oqfc9knnzuF1Fin",
        opId: "65adb9fe-1686-4fa3-8519-62b6b082d238",
        userArgs: {},
        cacheKey: `plasmic.$.${(() => {
          try {
            return undefined;
          } catch (e) {
            if (
              e instanceof TypeError ||
              e?.plasmicType === "PlasmicUndefinedDataError"
            ) {
              return "";
            }
            throw e;
          }
        })()}.$.65adb9fe-1686-4fa3-8519-62b6b082d238.$.`,
        invalidatedKeys: null,
        roleId: null
      };
    }),
    productPrice: usePlasmicDataOp(() => {
      return {
        sourceId: "iWyefF3oqfc9knnzuF1Fin",
        opId: "8d37026a-02c8-45b5-9876-1e7b6252d3fe",
        userArgs: {},
        cacheKey: `plasmic.$.8d37026a-02c8-45b5-9876-1e7b6252d3fe.$.`,
        invalidatedKeys: null,
        roleId: null
      };
    })
  };
  if (Object.keys(new$Queries).some(k => new$Queries[k] !== $queries[k])) {
    setDollarQueries(new$Queries);

    $queries = new$Queries;
  }

  return (
    <div
      data-plasmic-name={"root"}
      data-plasmic-override={overrides.root}
      data-plasmic-root={true}
      data-plasmic-for-node={forNode}
      className={classNames(
        projectcss.all,
        projectcss.root_reset,
        projectcss.plasmic_default_styles,
        projectcss.plasmic_mixins,
        projectcss.plasmic_tokens,
        plasmic_antd_5_hostless_css.plasmic_tokens,
        plasmic_library_tailwind_3_4_number_tokens_css.plasmic_tokens,
        plasmic_plasmic_rich_components_css.plasmic_tokens,
        sty.root
      )}
    >
      {renderPlasmicSlot({
        defaultContents: (
          <React.Fragment>
            <PageLoader
              className={classNames("__wab_instance", sty.pageLoader__ctSsl)}
              onMount={async () => {
                const $steps = {};

                $steps["updateStep"] = true
                  ? (() => {
                      const actionArgs = {
                        variable: {
                          objRoot: $state,
                          variablePath: ["step"]
                        },
                        operation: 0,
                        value: 1
                      };
                      return (({
                        variable,
                        value,
                        startIndex,
                        deleteCount
                      }) => {
                        if (!variable) {
                          return;
                        }
                        const { objRoot, variablePath } = variable;

                        $stateSet(objRoot, variablePath, value);
                        return value;
                      })?.apply(null, [actionArgs]);
                    })()
                  : undefined;
                if (
                  $steps["updateStep"] != null &&
                  typeof $steps["updateStep"] === "object" &&
                  typeof $steps["updateStep"].then === "function"
                ) {
                  $steps["updateStep"] = await $steps["updateStep"];
                }
              }}
              shouldRun={(() => {
                try {
                  return $ctx.query.stripe === "cancel";
                } catch (e) {
                  if (
                    e instanceof TypeError ||
                    e?.plasmicType === "PlasmicUndefinedDataError"
                  ) {
                    return true;
                  }
                  throw e;
                }
              })()}
            />

            <PageLoader
              className={classNames("__wab_instance", sty.pageLoader___7MPd0)}
              onMount={async () => {
                const $steps = {};

                $steps["updateStep"] = true
                  ? (() => {
                      const actionArgs = {
                        variable: {
                          objRoot: $state,
                          variablePath: ["step"]
                        },
                        operation: 0,
                        value: 2
                      };
                      return (({
                        variable,
                        value,
                        startIndex,
                        deleteCount
                      }) => {
                        if (!variable) {
                          return;
                        }
                        const { objRoot, variablePath } = variable;

                        $stateSet(objRoot, variablePath, value);
                        return value;
                      })?.apply(null, [actionArgs]);
                    })()
                  : undefined;
                if (
                  $steps["updateStep"] != null &&
                  typeof $steps["updateStep"] === "object" &&
                  typeof $steps["updateStep"].then === "function"
                ) {
                  $steps["updateStep"] = await $steps["updateStep"];
                }
              }}
              shouldRun={(() => {
                try {
                  return $ctx.query.onboarding === "done";
                } catch (e) {
                  if (
                    e instanceof TypeError ||
                    e?.plasmicType === "PlasmicUndefinedDataError"
                  ) {
                    return true;
                  }
                  throw e;
                }
              })()}
            />

            <SmartLoader
              action1={async () => {
                const $steps = {};

                $steps["updateStep"] = true
                  ? (() => {
                      const actionArgs = {
                        variable: {
                          objRoot: $state,
                          variablePath: ["step"]
                        },
                        operation: 0,
                        value: 1
                      };
                      return (({
                        variable,
                        value,
                        startIndex,
                        deleteCount
                      }) => {
                        if (!variable) {
                          return;
                        }
                        const { objRoot, variablePath } = variable;

                        $stateSet(objRoot, variablePath, value);
                        return value;
                      })?.apply(null, [actionArgs]);
                    })()
                  : undefined;
                if (
                  $steps["updateStep"] != null &&
                  typeof $steps["updateStep"] === "object" &&
                  typeof $steps["updateStep"].then === "function"
                ) {
                  $steps["updateStep"] = await $steps["updateStep"];
                }
              }}
              action2={async () => {
                const $steps = {};

                $steps["postgresGetList"] = true
                  ? (() => {
                      const actionArgs = {
                        dataOp: {
                          sourceId: "kVSSe8ab4TtzwRPnTeEeUp",
                          opId: "5ae87ae1-1181-451f-8714-6090c64eb1f2",
                          userArgs: {
                            filters: [$ctx.SupabaseUser.user.id]
                          },
                          cacheKey: null,
                          invalidatedKeys: null,
                          roleId: null
                        },
                        continueOnError: true
                      };
                      return (async ({ dataOp, continueOnError }) => {
                        try {
                          const response = await executePlasmicDataOp(dataOp, {
                            userAuthToken: dataSourcesCtx?.userAuthToken,
                            user: dataSourcesCtx?.user
                          });
                          await plasmicInvalidate(dataOp.invalidatedKeys);
                          return response;
                        } catch (e) {
                          if (!continueOnError) {
                            throw e;
                          }
                          return e;
                        }
                      })?.apply(null, [actionArgs]);
                    })()
                  : undefined;
                if (
                  $steps["postgresGetList"] != null &&
                  typeof $steps["postgresGetList"] === "object" &&
                  typeof $steps["postgresGetList"].then === "function"
                ) {
                  $steps["postgresGetList"] = await $steps["postgresGetList"];
                }

                $steps["updateStripeSessionId"] = true
                  ? (() => {
                      const actionArgs = {
                        variable: {
                          objRoot: $state,
                          variablePath: ["stripeSessionId"]
                        },
                        operation: 0,
                        value: $ctx.query.session_id
                      };
                      return (({
                        variable,
                        value,
                        startIndex,
                        deleteCount
                      }) => {
                        if (!variable) {
                          return;
                        }
                        const { objRoot, variablePath } = variable;

                        $stateSet(objRoot, variablePath, value);
                        return value;
                      })?.apply(null, [actionArgs]);
                    })()
                  : undefined;
                if (
                  $steps["updateStripeSessionId"] != null &&
                  typeof $steps["updateStripeSessionId"] === "object" &&
                  typeof $steps["updateStripeSessionId"].then === "function"
                ) {
                  $steps["updateStripeSessionId"] = await $steps[
                    "updateStripeSessionId"
                  ];
                }

                $steps["httpGet"] = true
                  ? (() => {
                      const actionArgs = {
                        dataOp: {
                          sourceId: "iWyefF3oqfc9knnzuF1Fin",
                          opId: "ff777f02-09eb-450c-8314-de92f4c472c4",
                          userArgs: {
                            path: [
                              "v1/checkout/sessions/" + $state.stripeSessionId
                            ]
                          },
                          cacheKey: null,
                          invalidatedKeys: null,
                          roleId: null
                        }
                      };
                      return (async ({ dataOp, continueOnError }) => {
                        try {
                          const response = await executePlasmicDataOp(dataOp, {
                            userAuthToken: dataSourcesCtx?.userAuthToken,
                            user: dataSourcesCtx?.user
                          });
                          await plasmicInvalidate(dataOp.invalidatedKeys);
                          return response;
                        } catch (e) {
                          if (!continueOnError) {
                            throw e;
                          }
                          return e;
                        }
                      })?.apply(null, [actionArgs]);
                    })()
                  : undefined;
                if (
                  $steps["httpGet"] != null &&
                  typeof $steps["httpGet"] === "object" &&
                  typeof $steps["httpGet"].then === "function"
                ) {
                  $steps["httpGet"] = await $steps["httpGet"];
                }

                $steps["updateCustomerId"] = true
                  ? (() => {
                      const actionArgs = {
                        variable: {
                          objRoot: $state,
                          variablePath: ["customerId"]
                        },
                        operation: 0,
                        value: $steps.httpGet.data.response.customer
                      };
                      return (({
                        variable,
                        value,
                        startIndex,
                        deleteCount
                      }) => {
                        if (!variable) {
                          return;
                        }
                        const { objRoot, variablePath } = variable;

                        $stateSet(objRoot, variablePath, value);
                        return value;
                      })?.apply(null, [actionArgs]);
                    })()
                  : undefined;
                if (
                  $steps["updateCustomerId"] != null &&
                  typeof $steps["updateCustomerId"] === "object" &&
                  typeof $steps["updateCustomerId"].then === "function"
                ) {
                  $steps["updateCustomerId"] = await $steps["updateCustomerId"];
                }

                $steps["updateStripeStatus"] = true
                  ? (() => {
                      const actionArgs = {
                        variable: {
                          objRoot: $state,
                          variablePath: ["stripeStatus"]
                        },
                        operation: 0,
                        value: $steps.httpGet.data.response.status
                      };
                      return (({
                        variable,
                        value,
                        startIndex,
                        deleteCount
                      }) => {
                        if (!variable) {
                          return;
                        }
                        const { objRoot, variablePath } = variable;

                        $stateSet(objRoot, variablePath, value);
                        return value;
                      })?.apply(null, [actionArgs]);
                    })()
                  : undefined;
                if (
                  $steps["updateStripeStatus"] != null &&
                  typeof $steps["updateStripeStatus"] === "object" &&
                  typeof $steps["updateStripeStatus"].then === "function"
                ) {
                  $steps["updateStripeStatus"] = await $steps[
                    "updateStripeStatus"
                  ];
                }

                $steps["updateStripeSubscriptionId"] = true
                  ? (() => {
                      const actionArgs = {
                        variable: {
                          objRoot: $state,
                          variablePath: ["stripeSubscriptionId"]
                        },
                        operation: 0,
                        value: $steps.httpGet.data.response.subscription
                      };
                      return (({
                        variable,
                        value,
                        startIndex,
                        deleteCount
                      }) => {
                        if (!variable) {
                          return;
                        }
                        const { objRoot, variablePath } = variable;

                        $stateSet(objRoot, variablePath, value);
                        return value;
                      })?.apply(null, [actionArgs]);
                    })()
                  : undefined;
                if (
                  $steps["updateStripeSubscriptionId"] != null &&
                  typeof $steps["updateStripeSubscriptionId"] === "object" &&
                  typeof $steps["updateStripeSubscriptionId"].then ===
                    "function"
                ) {
                  $steps["updateStripeSubscriptionId"] = await $steps[
                    "updateStripeSubscriptionId"
                  ];
                }

                $steps["updateCreateAccount"] = true
                  ? (() => {
                      const actionArgs = {
                        variable: {
                          objRoot: $state,
                          variablePath: ["createAccount"]
                        },
                        operation: 0,
                        value: true
                      };
                      return (({
                        variable,
                        value,
                        startIndex,
                        deleteCount
                      }) => {
                        if (!variable) {
                          return;
                        }
                        const { objRoot, variablePath } = variable;

                        $stateSet(objRoot, variablePath, value);
                        return value;
                      })?.apply(null, [actionArgs]);
                    })()
                  : undefined;
                if (
                  $steps["updateCreateAccount"] != null &&
                  typeof $steps["updateCreateAccount"] === "object" &&
                  typeof $steps["updateCreateAccount"].then === "function"
                ) {
                  $steps["updateCreateAccount"] = await $steps[
                    "updateCreateAccount"
                  ];
                }
              }}
              action3={async () => {
                const $steps = {};

                $steps["postgresCreate"] = true
                  ? (() => {
                      const actionArgs = {
                        dataOp: {
                          sourceId: "kVSSe8ab4TtzwRPnTeEeUp",
                          opId: "c6e91e23-0a40-4f7a-bbad-90ee42bebca6",
                          userArgs: {
                            variables: [
                              $state.customerId,
                              $state.priceId,
                              $state.stripeSessionId,
                              $state.stripeStatus,
                              $state.stripeSubscriptionId,
                              $ctx.SupabaseUser.user.id,
                              $state.productId,
                              $state.productId === "prod_S81KBWHPyJa53z"
                                ? 0
                                : 2,
                              $state.productId === "prod_S81KBWHPyJa53z"
                                ? 3
                                : 8,
                              $state.productId === "prod_S81KBWHPyJa53z" ? 1 : 4
                            ]
                          },
                          cacheKey: null,
                          invalidatedKeys: ["plasmic_refresh_all"],
                          roleId: null
                        },
                        continueOnError: false
                      };
                      return (async ({ dataOp, continueOnError }) => {
                        try {
                          const response = await executePlasmicDataOp(dataOp, {
                            userAuthToken: dataSourcesCtx?.userAuthToken,
                            user: dataSourcesCtx?.user
                          });
                          await plasmicInvalidate(dataOp.invalidatedKeys);
                          return response;
                        } catch (e) {
                          if (!continueOnError) {
                            throw e;
                          }
                          return e;
                        }
                      })?.apply(null, [actionArgs]);
                    })()
                  : undefined;
                if (
                  $steps["postgresCreate"] != null &&
                  typeof $steps["postgresCreate"] === "object" &&
                  typeof $steps["postgresCreate"].then === "function"
                ) {
                  $steps["postgresCreate"] = await $steps["postgresCreate"];
                }

                $steps["goToPage"] = true
                  ? (() => {
                      const actionArgs = {
                        destination: (() => {
                          try {
                            return $ctx.pagePath + "?onboarding=done";
                          } catch (e) {
                            if (
                              e instanceof TypeError ||
                              e?.plasmicType === "PlasmicUndefinedDataError"
                            ) {
                              return undefined;
                            }
                            throw e;
                          }
                        })()
                      };
                      return (({ destination }) => {
                        if (
                          typeof destination === "string" &&
                          destination.startsWith("#")
                        ) {
                          document
                            .getElementById(destination.substr(1))
                            .scrollIntoView({ behavior: "smooth" });
                        } else {
                          __nextRouter?.push(destination);
                        }
                      })?.apply(null, [actionArgs]);
                    })()
                  : undefined;
                if (
                  $steps["goToPage"] != null &&
                  typeof $steps["goToPage"] === "object" &&
                  typeof $steps["goToPage"].then === "function"
                ) {
                  $steps["goToPage"] = await $steps["goToPage"];
                }
              }}
              className={classNames("__wab_instance", sty.smartLoader__pIz08)}
              condition1={true}
              condition2={(() => {
                try {
                  return $state.createAccount === false;
                } catch (e) {
                  if (
                    e instanceof TypeError ||
                    e?.plasmicType === "PlasmicUndefinedDataError"
                  ) {
                    return undefined;
                  }
                  throw e;
                }
              })()}
              condition3={(() => {
                try {
                  return $state.createAccount === true;
                } catch (e) {
                  if (
                    e instanceof TypeError ||
                    e?.plasmicType === "PlasmicUndefinedDataError"
                  ) {
                    return undefined;
                  }
                  throw e;
                }
              })()}
              condition4={false}
              condition5={false}
              shouldRun={(() => {
                try {
                  return $ctx.query.onboarding === "success";
                } catch (e) {
                  if (
                    e instanceof TypeError ||
                    e?.plasmicType === "PlasmicUndefinedDataError"
                  ) {
                    return true;
                  }
                  throw e;
                }
              })()}
            />

            <Stack__
              as={"div"}
              hasGap={true}
              className={classNames(projectcss.all, sty.freeBox__p3Qtn)}
            >
              <div className={classNames(projectcss.all, sty.freeBox__gzAcB)}>
                <Icon10Icon
                  className={classNames(projectcss.all, sty.svg__vledv)}
                  role={"img"}
                />
              </div>
              <div className={classNames(projectcss.all, sty.freeBox___1WY2N)}>
                <div className={classNames(projectcss.all, sty.freeBox__jvKhF)}>
                  <PlasmicImg__
                    alt={""}
                    className={classNames(sty.img__iTJwg)}
                    displayHeight={"132px"}
                    displayMaxHeight={"none"}
                    displayMaxWidth={"100%"}
                    displayMinHeight={"0"}
                    displayMinWidth={"0"}
                    displayWidth={"132px"}
                    loading={"lazy"}
                    src={{
                      src: "/plasmic/jam_production_ðŸš€/images/frame7.svg",
                      fullWidth: 132,
                      fullHeight: 132,
                      aspectRatio: 1
                    }}
                  />
                </div>
                {(() => {
                  const child$Props = {
                    className: classNames("__wab_instance", sty.form__sDl4U),
                    formItems: [
                      { label: "Name", name: "name", inputType: "Text" },
                      {
                        label: "Message",
                        name: "message",
                        inputType: "Text Area"
                      }
                    ],
                    labelCol: { span: 8, horizontalOnly: true },
                    layout: "vertical",
                    mode: "advanced",
                    submitSlot: null,
                    wrapperCol: { span: 16, horizontalOnly: true }
                  };

                  return (
                    <FormWrapper {...child$Props}>
                      <FormItemWrapper
                        className={classNames(
                          "__wab_instance",
                          sty.formField__dP2T3
                        )}
                        label={"Nom de l'entreprise*"}
                        name={"name"}
                      >
                        {(() => {
                          const child$Props = {
                            className: classNames(
                              "__wab_instance",
                              sty.input__gbZoG
                            )
                          };

                          return <AntdInput {...child$Props} />;
                        })()}
                      </FormItemWrapper>
                      <FormItemWrapper
                        className={classNames(
                          "__wab_instance",
                          sty.formField__mi9Ee
                        )}
                        label={"Pr\u00e9sentation courte"}
                        name={"message"}
                      >
                        {(() => {
                          const child$Props = {
                            className: classNames(
                              "__wab_instance",
                              sty.textArea__xMxFx
                            )
                          };

                          return <AntdTextArea {...child$Props} />;
                        })()}
                      </FormItemWrapper>
                      <FormItemWrapper
                        className={classNames(
                          "__wab_instance",
                          sty.formField__gTnpV
                        )}
                        label={
                          <div
                            className={classNames(
                              projectcss.all,
                              projectcss.__wab_text,
                              sty.text__qaBkp
                            )}
                          >
                            {"Adresse"}
                          </div>
                        }
                      >
                        {(() => {
                          const child$Props = {
                            className: classNames(
                              "__wab_instance",
                              sty.input__wKJp
                            )
                          };

                          return <AntdInput {...child$Props} />;
                        })()}
                      </FormItemWrapper>
                      <Button
                        className={classNames(
                          "__wab_instance",
                          sty.button__qq5Wt
                        )}
                        end={
                          <GroupIcon
                            className={classNames(
                              projectcss.all,
                              sty.svg__d5FJy
                            )}
                            role={"img"}
                          />
                        }
                        iconEnd={true}
                        label={
                          <div
                            className={classNames(
                              projectcss.all,
                              projectcss.__wab_text,
                              sty.text__zrqZc
                            )}
                          >
                            {"continuer"}
                          </div>
                        }
                        onClick={async event => {
                          const $steps = {};

                          $steps["goStep1"] = true
                            ? (() => {
                                const actionArgs = {
                                  variable: {
                                    objRoot: $state,
                                    variablePath: ["step"]
                                  },
                                  operation: 2,
                                  value: 1
                                };
                                return (({
                                  variable,
                                  value,
                                  startIndex,
                                  deleteCount
                                }) => {
                                  if (!variable) {
                                    return;
                                  }
                                  const { objRoot, variablePath } = variable;

                                  const oldValue = $stateGet(
                                    objRoot,
                                    variablePath
                                  );
                                  $stateSet(
                                    objRoot,
                                    variablePath,
                                    oldValue + 1
                                  );
                                  return oldValue + 1;
                                })?.apply(null, [actionArgs]);
                              })()
                            : undefined;
                          if (
                            $steps["goStep1"] != null &&
                            typeof $steps["goStep1"] === "object" &&
                            typeof $steps["goStep1"].then === "function"
                          ) {
                            $steps["goStep1"] = await $steps["goStep1"];
                          }
                        }}
                        submitsForm={true}
                      />
                    </FormWrapper>
                  );
                })()}
                {(() => {
                  const child$Props = {
                    className: classNames("__wab_instance", sty.form__bun84),
                    formItems: [
                      { label: "Name", name: "name", inputType: "Text" },
                      {
                        label: "Message",
                        name: "message",
                        inputType: "Text Area"
                      }
                    ],
                    labelCol: { span: 8, horizontalOnly: true },
                    layout: "vertical",
                    mode: "advanced",
                    onFinish: async values => {
                      const $steps = {};
                    },
                    submitSlot: null,
                    wrapperCol: { span: 16, horizontalOnly: true }
                  };

                  return (
                    <FormWrapper {...child$Props}>
                      <Stack__
                        as={"div"}
                        hasGap={true}
                        className={classNames(
                          projectcss.all,
                          sty.freeBox___4D4Py
                        )}
                      >
                        <h1
                          className={classNames(
                            projectcss.all,
                            projectcss.h1,
                            projectcss.__wab_text,
                            sty.h1__gtVd
                          )}
                        >
                          {"Votre profile entreprise"}
                        </h1>
                        <UploadWrapper
                          accept={""}
                          className={classNames(
                            "__wab_instance",
                            sty.upload__pEh6
                          )}
                          files={[]}
                          maxCount={1}
                          onFilesChange={async files => {
                            const $steps = {};

                            $steps["supabaseUploadFile"] = true
                              ? (() => {
                                  const actionArgs = {
                                    dataOp: {
                                      sourceId: "rtEg85U6Vbyi94cRAe93i7",
                                      opId: "84c0bb0b-0e3b-43a7-ae52-d0cf288eb28f",
                                      userArgs: {
                                        path: [
                                          $ctx.SupabaseUser.user.id,
                                          $state.upload2.files[0].name
                                        ],
                                        content: [
                                          $state.upload2.files[0].contents
                                        ],
                                        contentType: [
                                          $state.upload2.files[0].type
                                        ]
                                      },
                                      cacheKey: null,
                                      invalidatedKeys: [],
                                      roleId: null
                                    }
                                  };
                                  return (async ({
                                    dataOp,
                                    continueOnError
                                  }) => {
                                    try {
                                      const response =
                                        await executePlasmicDataOp(dataOp, {
                                          userAuthToken:
                                            dataSourcesCtx?.userAuthToken,
                                          user: dataSourcesCtx?.user
                                        });
                                      await plasmicInvalidate(
                                        dataOp.invalidatedKeys
                                      );
                                      return response;
                                    } catch (e) {
                                      if (!continueOnError) {
                                        throw e;
                                      }
                                      return e;
                                    }
                                  })?.apply(null, [actionArgs]);
                                })()
                              : undefined;
                            if (
                              $steps["supabaseUploadFile"] != null &&
                              typeof $steps["supabaseUploadFile"] ===
                                "object" &&
                              typeof $steps["supabaseUploadFile"].then ===
                                "function"
                            ) {
                              $steps["supabaseUploadFile"] = await $steps[
                                "supabaseUploadFile"
                              ];
                            }

                            $steps["postgresUpdateById"] = true
                              ? (() => {
                                  const actionArgs = {
                                    dataOp: {
                                      sourceId: "kVSSe8ab4TtzwRPnTeEeUp",
                                      opId: "ca8056ed-4ec7-4218-bb8b-d4f4da770307",
                                      userArgs: {
                                        keys: [$ctx.SupabaseUser.user.id],
                                        variables: [
                                          $steps.supabaseUploadFile?.path.split(
                                            "/"
                                          )[1]
                                        ]
                                      },
                                      cacheKey: null,
                                      invalidatedKeys: ["plasmic_refresh_all"],
                                      roleId: null
                                    }
                                  };
                                  return (async ({
                                    dataOp,
                                    continueOnError
                                  }) => {
                                    try {
                                      const response =
                                        await executePlasmicDataOp(dataOp, {
                                          userAuthToken:
                                            dataSourcesCtx?.userAuthToken,
                                          user: dataSourcesCtx?.user
                                        });
                                      await plasmicInvalidate(
                                        dataOp.invalidatedKeys
                                      );
                                      return response;
                                    } catch (e) {
                                      if (!continueOnError) {
                                        throw e;
                                      }
                                      return e;
                                    }
                                  })?.apply(null, [actionArgs]);
                                })()
                              : undefined;
                            if (
                              $steps["postgresUpdateById"] != null &&
                              typeof $steps["postgresUpdateById"] ===
                                "object" &&
                              typeof $steps["postgresUpdateById"].then ===
                                "function"
                            ) {
                              $steps["postgresUpdateById"] = await $steps[
                                "postgresUpdateById"
                              ];
                            }
                          }}
                          showUploadList={false}
                        >
                          <PlasmicImg__
                            alt={""}
                            className={classNames(sty.img__heBj1)}
                            displayHeight={"132px"}
                            displayMaxHeight={"none"}
                            displayMaxWidth={"100%"}
                            displayMinHeight={"0"}
                            displayMinWidth={"0"}
                            displayWidth={"132px"}
                            loading={"lazy"}
                            src={{
                              src: "/plasmic/jam_production_ðŸš€/images/frame7.svg",
                              fullWidth: 132,
                              fullHeight: 132,
                              aspectRatio: 1
                            }}
                          />

                          <div
                            className={classNames(
                              projectcss.all,
                              sty.freeBox__hTq4Q
                            )}
                          >
                            <div
                              className={classNames(
                                projectcss.all,
                                sty.freeBox__u9Zap
                              )}
                            />

                            <PhPencilSimpleIcon
                              className={classNames(
                                projectcss.all,
                                sty.svg__xQyfC
                              )}
                              role={"img"}
                            />
                          </div>
                          <div
                            className={classNames(
                              projectcss.all,
                              sty.freeBox__hgvoq
                            )}
                            onClick={async event => {
                              const $steps = {};

                              $steps["updateUpload2Files"] = true
                                ? (() => {
                                    const actionArgs = {
                                      variable: {
                                        objRoot: $state,
                                        variablePath: ["upload2", "files"]
                                      },
                                      operation: 1
                                    };
                                    return (({
                                      variable,
                                      value,
                                      startIndex,
                                      deleteCount
                                    }) => {
                                      if (!variable) {
                                        return;
                                      }
                                      const { objRoot, variablePath } =
                                        variable;

                                      $stateSet(
                                        objRoot,
                                        variablePath,
                                        undefined
                                      );
                                      return undefined;
                                    })?.apply(null, [actionArgs]);
                                  })()
                                : undefined;
                              if (
                                $steps["updateUpload2Files"] != null &&
                                typeof $steps["updateUpload2Files"] ===
                                  "object" &&
                                typeof $steps["updateUpload2Files"].then ===
                                  "function"
                              ) {
                                $steps["updateUpload2Files"] = await $steps[
                                  "updateUpload2Files"
                                ];
                              }

                              $steps["runCode"] = true
                                ? (() => {
                                    const actionArgs = {
                                      customFunction: async () => {
                                        return event.stopPropagation();
                                      }
                                    };
                                    return (({ customFunction }) => {
                                      return customFunction();
                                    })?.apply(null, [actionArgs]);
                                  })()
                                : undefined;
                              if (
                                $steps["runCode"] != null &&
                                typeof $steps["runCode"] === "object" &&
                                typeof $steps["runCode"].then === "function"
                              ) {
                                $steps["runCode"] = await $steps["runCode"];
                              }

                              $steps["postgresUpdateMany"] = true
                                ? (() => {
                                    const actionArgs = {
                                      dataOp: {
                                        sourceId: "kVSSe8ab4TtzwRPnTeEeUp",
                                        opId: "00154d6f-41ac-4e44-8d5a-da12df8e7c56",
                                        userArgs: {
                                          variables: [null],
                                          conditions: [
                                            $ctx.SupabaseUser.user.id
                                          ]
                                        },
                                        cacheKey: null,
                                        invalidatedKeys: [
                                          "plasmic_refresh_all"
                                        ],
                                        roleId: null
                                      }
                                    };
                                    return (async ({
                                      dataOp,
                                      continueOnError
                                    }) => {
                                      try {
                                        const response =
                                          await executePlasmicDataOp(dataOp, {
                                            userAuthToken:
                                              dataSourcesCtx?.userAuthToken,
                                            user: dataSourcesCtx?.user
                                          });
                                        await plasmicInvalidate(
                                          dataOp.invalidatedKeys
                                        );
                                        return response;
                                      } catch (e) {
                                        if (!continueOnError) {
                                          throw e;
                                        }
                                        return e;
                                      }
                                    })?.apply(null, [actionArgs]);
                                  })()
                                : undefined;
                              if (
                                $steps["postgresUpdateMany"] != null &&
                                typeof $steps["postgresUpdateMany"] ===
                                  "object" &&
                                typeof $steps["postgresUpdateMany"].then ===
                                  "function"
                              ) {
                                $steps["postgresUpdateMany"] = await $steps[
                                  "postgresUpdateMany"
                                ];
                              }
                            }}
                          >
                            <div
                              className={classNames(
                                projectcss.all,
                                sty.freeBox__nhUba
                              )}
                            />

                            <PhTrashIcon
                              className={classNames(
                                projectcss.all,
                                sty.svg__gNgcs
                              )}
                              role={"img"}
                            />
                          </div>
                        </UploadWrapper>
                      </Stack__>
                      <FormItemWrapper
                        className={classNames(
                          "__wab_instance",
                          sty.formField__nhwmh
                        )}
                        label={
                          <div
                            className={classNames(
                              projectcss.all,
                              projectcss.__wab_text,
                              sty.text__wNtOc
                            )}
                          >
                            {"Nom de l'entreprise*"}
                          </div>
                        }
                        name={"name"}
                      >
                        <TextInput
                          className={classNames(
                            "__wab_instance",
                            sty.textInput___3JHb
                          )}
                          placeholder={"Nom de l'entreprise"}
                        />
                      </FormItemWrapper>
                      <FormItemWrapper
                        className={classNames(
                          "__wab_instance",
                          sty.formField__kSx23
                        )}
                        label={
                          <div
                            className={classNames(
                              projectcss.all,
                              projectcss.__wab_text,
                              sty.text__dmcEy
                            )}
                          >
                            {"Pr\u00e9sentation courte"}
                          </div>
                        }
                        name={"description"}
                      >
                        <div
                          className={classNames(
                            projectcss.all,
                            sty.freeBox__cqCiF
                          )}
                        >
                          {(() => {
                            const child$Props = {
                              className: classNames(
                                "__wab_instance",
                                sty.textArea__aWvjj
                              ),
                              placeholder:
                                "Pr\u00e9sentez votre entreprise en quelques lignes..."
                            };

                            return <AntdTextArea {...child$Props} />;
                          })()}
                        </div>
                      </FormItemWrapper>
                      <FormItemWrapper
                        className={classNames(
                          "__wab_instance",
                          sty.formField__w9KEa
                        )}
                        label={
                          <div
                            className={classNames(
                              projectcss.all,
                              projectcss.__wab_text,
                              sty.text__kwShk
                            )}
                          >
                            {"Adresse*"}
                          </div>
                        }
                        name={"address"}
                      >
                        <TextInput
                          className={classNames(
                            "__wab_instance",
                            sty.textInput__sjpZx
                          )}
                          placeholder={"Rue"}
                        />
                      </FormItemWrapper>
                      <Stack__
                        as={"div"}
                        hasGap={true}
                        className={classNames(
                          projectcss.all,
                          sty.freeBox__aBsfI
                        )}
                      >
                        <FormItemWrapper
                          className={classNames(
                            "__wab_instance",
                            sty.formField__weOlu
                          )}
                          label={
                            <div
                              className={classNames(
                                projectcss.all,
                                projectcss.__wab_text,
                                sty.text__vvUTt
                              )}
                            >
                              {"Code postal*"}
                            </div>
                          }
                          name={"postal_code"}
                        >
                          <TextInput
                            className={classNames(
                              "__wab_instance",
                              sty.textInput__myA4K
                            )}
                            placeholder={"Code postal"}
                          />
                        </FormItemWrapper>
                        <FormItemWrapper
                          className={classNames(
                            "__wab_instance",
                            sty.formField__vP7TH
                          )}
                          label={
                            <div
                              className={classNames(
                                projectcss.all,
                                projectcss.__wab_text,
                                sty.text___9AqEc
                              )}
                            >
                              {"Ville*"}
                            </div>
                          }
                          name={"city"}
                        >
                          <TextInput
                            className={classNames(
                              "__wab_instance",
                              sty.textInput__xkfno
                            )}
                            placeholder={"Ville"}
                          />
                        </FormItemWrapper>
                      </Stack__>
                      <FormItemWrapper
                        className={classNames(
                          "__wab_instance",
                          sty.formField__hrnYm
                        )}
                        label={
                          <div
                            className={classNames(
                              projectcss.all,
                              projectcss.__wab_text,
                              sty.text__w0AzF
                            )}
                          >
                            {"Pays*"}
                          </div>
                        }
                        name={"country"}
                      >
                        <Select
                          className={classNames(
                            "__wab_instance",
                            sty.select__slyqP
                          )}
                          items={(_par =>
                            !_par ? [] : Array.isArray(_par) ? _par : [_par])(
                            (() => {
                              try {
                                return $queries.getCountries.data;
                              } catch (e) {
                                if (
                                  e instanceof TypeError ||
                                  e?.plasmicType === "PlasmicUndefinedDataError"
                                ) {
                                  return [];
                                }
                                throw e;
                              }
                            })()
                          ).map((__plasmic_item_0, __plasmic_idx_0) => {
                            const currentItem = __plasmic_item_0;
                            const currentIndex = __plasmic_idx_0;
                            return (
                              <MenuItem
                                key={currentIndex}
                                label={(() => {
                                  try {
                                    return currentItem.Name;
                                  } catch (e) {
                                    if (
                                      e instanceof TypeError ||
                                      e?.plasmicType ===
                                        "PlasmicUndefinedDataError"
                                    ) {
                                      return undefined;
                                    }
                                    throw e;
                                  }
                                })()}
                                value={currentItem.Name}
                              />
                            );
                          })}
                          label={
                            <div
                              className={classNames(
                                projectcss.all,
                                projectcss.__wab_text,
                                sty.text___06DZh
                              )}
                            >
                              {"Label"}
                            </div>
                          }
                          placeholder={"Pays"}
                          showLabel={false}
                        />
                      </FormItemWrapper>
                      <FormItemWrapper
                        className={classNames(
                          "__wab_instance",
                          sty.formField__u2Idh
                        )}
                        label={
                          <div
                            className={classNames(
                              projectcss.all,
                              projectcss.__wab_text,
                              sty.text__hu6Rj
                            )}
                          >
                            {"SIREN*"}
                          </div>
                        }
                        name={"siren"}
                      >
                        <TextInput
                          className={classNames(
                            "__wab_instance",
                            sty.textInput__vI2P1
                          )}
                          placeholder={"Num\u00e9ro de SIREN"}
                        />
                      </FormItemWrapper>
                      <Stack__
                        as={"div"}
                        hasGap={true}
                        className={classNames(
                          projectcss.all,
                          sty.freeBox__f1M0V
                        )}
                      >
                        <FormItemWrapper
                          className={classNames(
                            "__wab_instance",
                            sty.formField__iDqR
                          )}
                          label={
                            <div
                              className={classNames(
                                projectcss.all,
                                projectcss.__wab_text,
                                sty.text___9FYfR
                              )}
                            >
                              {"Secteur d'activit\u00e9*"}
                            </div>
                          }
                          name={"sector"}
                        >
                          <AntdSelect
                            className={classNames(
                              "__wab_instance",
                              sty.select__kWjRj
                            )}
                            defaultStylesClassName={classNames(
                              projectcss.root_reset,
                              projectcss.plasmic_default_styles,
                              projectcss.plasmic_mixins,
                              projectcss.plasmic_tokens,
                              plasmic_antd_5_hostless_css.plasmic_tokens,
                              plasmic_library_tailwind_3_4_number_tokens_css.plasmic_tokens,
                              plasmic_plasmic_rich_components_css.plasmic_tokens
                            )}
                            options={[
                              {
                                value: "option1",
                                label: "Option 1",
                                type: "option"
                              },
                              {
                                value: "option2",
                                label: "Option 2",
                                type: "option"
                              }
                            ]}
                            placeholder={""}
                            popupScopeClassName={sty["select__kWjRj__popup"]}
                          />
                        </FormItemWrapper>
                        <FormItemWrapper
                          className={classNames(
                            "__wab_instance",
                            sty.formField__vJuam
                          )}
                          label={
                            <div
                              className={classNames(
                                projectcss.all,
                                projectcss.__wab_text,
                                sty.text__p0SY7
                              )}
                            >
                              {"Taille de l'entreprise*"}
                            </div>
                          }
                          name={"team_size"}
                        >
                          <AntdSelect
                            className={classNames(
                              "__wab_instance",
                              sty.select__sxffw
                            )}
                            defaultStylesClassName={classNames(
                              projectcss.root_reset,
                              projectcss.plasmic_default_styles,
                              projectcss.plasmic_mixins,
                              projectcss.plasmic_tokens,
                              plasmic_antd_5_hostless_css.plasmic_tokens,
                              plasmic_library_tailwind_3_4_number_tokens_css.plasmic_tokens,
                              plasmic_plasmic_rich_components_css.plasmic_tokens
                            )}
                            options={[]}
                            placeholder={""}
                            popupScopeClassName={sty["select__sxffw__popup"]}
                          />
                        </FormItemWrapper>
                      </Stack__>
                      <FormItemWrapper
                        className={classNames(
                          "__wab_instance",
                          sty.formField___7PftW
                        )}
                        label={
                          <div
                            className={classNames(
                              projectcss.all,
                              projectcss.__wab_text,
                              sty.text___0MQv8
                            )}
                          >
                            {"Site web"}
                          </div>
                        }
                        name={"website"}
                      >
                        <TextInput
                          className={classNames(
                            "__wab_instance",
                            sty.textInput__ec8Ow
                          )}
                          placeholder={"https://"}
                        />
                      </FormItemWrapper>
                      <Stack__
                        as={"div"}
                        hasGap={true}
                        className={classNames(
                          projectcss.all,
                          sty.freeBox__lsHX
                        )}
                      >
                        <FormItemWrapper
                          className={classNames(
                            "__wab_instance",
                            sty.formField___3DIlo
                          )}
                          label={
                            <div
                              className={classNames(
                                projectcss.all,
                                projectcss.__wab_text,
                                sty.text__qXh2P
                              )}
                            >
                              {"Kbis"}
                            </div>
                          }
                          name={"kbis_file"}
                        >
                          <UploadWrapper
                            accept={""}
                            className={classNames(
                              "__wab_instance",
                              sty.upload__vlt1J
                            )}
                            files={[]}
                            maxCount={1}
                            onFilesChange={async files => {
                              const $steps = {};

                              $steps["supabaseUploadFile"] = true
                                ? (() => {
                                    const actionArgs = {
                                      dataOp: {
                                        sourceId: "rtEg85U6Vbyi94cRAe93i7",
                                        opId: "2c27e5ea-862c-480e-bff8-3da6871e0b04",
                                        userArgs: {
                                          path: [
                                            $ctx.SupabaseUser.user.id,
                                            $state.upload.files[0].name
                                          ],
                                          content: [
                                            $state.upload.files[0].contents
                                          ],
                                          contentType: [
                                            $state.upload.files[0].type
                                          ],
                                          upsert: [true]
                                        },
                                        cacheKey: null,
                                        invalidatedKeys: [
                                          "plasmic_refresh_all"
                                        ],
                                        roleId: null
                                      }
                                    };
                                    return (async ({
                                      dataOp,
                                      continueOnError
                                    }) => {
                                      try {
                                        const response =
                                          await executePlasmicDataOp(dataOp, {
                                            userAuthToken:
                                              dataSourcesCtx?.userAuthToken,
                                            user: dataSourcesCtx?.user
                                          });
                                        await plasmicInvalidate(
                                          dataOp.invalidatedKeys
                                        );
                                        return response;
                                      } catch (e) {
                                        if (!continueOnError) {
                                          throw e;
                                        }
                                        return e;
                                      }
                                    })?.apply(null, [actionArgs]);
                                  })()
                                : undefined;
                              if (
                                $steps["supabaseUploadFile"] != null &&
                                typeof $steps["supabaseUploadFile"] ===
                                  "object" &&
                                typeof $steps["supabaseUploadFile"].then ===
                                  "function"
                              ) {
                                $steps["supabaseUploadFile"] = await $steps[
                                  "supabaseUploadFile"
                                ];
                              }

                              $steps["postgresUpdateById"] = true
                                ? (() => {
                                    const actionArgs = {
                                      dataOp: {
                                        sourceId: "kVSSe8ab4TtzwRPnTeEeUp",
                                        opId: "1d316c45-4c3c-4fdb-88bb-e87b178387e4",
                                        userArgs: {
                                          keys: [$ctx.SupabaseUser.user.id],
                                          variables: [
                                            $steps.supabaseUploadFile?.path.split(
                                              "/"
                                            )[1],
                                            (() => {})()
                                          ]
                                        },
                                        cacheKey: null,
                                        invalidatedKeys: [
                                          "plasmic_refresh_all"
                                        ],
                                        roleId: null
                                      }
                                    };
                                    return (async ({
                                      dataOp,
                                      continueOnError
                                    }) => {
                                      try {
                                        const response =
                                          await executePlasmicDataOp(dataOp, {
                                            userAuthToken:
                                              dataSourcesCtx?.userAuthToken,
                                            user: dataSourcesCtx?.user
                                          });
                                        await plasmicInvalidate(
                                          dataOp.invalidatedKeys
                                        );
                                        return response;
                                      } catch (e) {
                                        if (!continueOnError) {
                                          throw e;
                                        }
                                        return e;
                                      }
                                    })?.apply(null, [actionArgs]);
                                  })()
                                : undefined;
                              if (
                                $steps["postgresUpdateById"] != null &&
                                typeof $steps["postgresUpdateById"] ===
                                  "object" &&
                                typeof $steps["postgresUpdateById"].then ===
                                  "function"
                              ) {
                                $steps["postgresUpdateById"] = await $steps[
                                  "postgresUpdateById"
                                ];
                              }
                            }}
                            showUploadList={false}
                          >
                            <div
                              className={classNames(
                                projectcss.all,
                                sty.freeBox__gfyzL
                              )}
                            >
                              <Stack__
                                as={PlasmicImg__}
                                hasGap={true}
                                alt={""}
                                className={classNames(sty.img__kw0X)}
                                displayHeight={"39px"}
                                displayMaxHeight={"none"}
                                displayMaxWidth={"100%"}
                                displayMinHeight={"0"}
                                displayMinWidth={"0"}
                                displayWidth={"39px"}
                                loading={"lazy"}
                                src={{
                                  src: "/plasmic/jam_production_ðŸš€/images/frame1437254220.svg",
                                  fullWidth: 39,
                                  fullHeight: 39,
                                  aspectRatio: 1
                                }}
                              />

                              <div
                                className={classNames(
                                  projectcss.all,
                                  projectcss.__wab_text,
                                  sty.text__gd1L
                                )}
                              >
                                {"Importer ou d\u00e9poser un fichier"}
                              </div>
                              <div
                                className={classNames(
                                  projectcss.all,
                                  projectcss.__wab_text,
                                  sty.text__q8JzT
                                )}
                              >
                                {"PDF, DOC, DOCX, JPG (max. 2Mo)"}
                              </div>
                            </div>
                          </UploadWrapper>
                        </FormItemWrapper>
                        <FormItemWrapper
                          className={classNames(
                            "__wab_instance",
                            sty.formField__kd8Q0
                          )}
                          label={
                            <div
                              className={classNames(
                                projectcss.all,
                                projectcss.__wab_text,
                                sty.text__j9HZv
                              )}
                            >
                              {"Pi\u00e8ce d'identit\u00e9"}
                            </div>
                          }
                          name={"identity_file"}
                        >
                          <UploadWrapper
                            accept={""}
                            className={classNames(
                              "__wab_instance",
                              sty.upload__dDyZu
                            )}
                            files={[]}
                            maxCount={1}
                            onFilesChange={async files => {
                              const $steps = {};

                              $steps["supabaseUploadFile"] = true
                                ? (() => {
                                    const actionArgs = {
                                      dataOp: {
                                        sourceId: "rtEg85U6Vbyi94cRAe93i7",
                                        opId: "2c27e5ea-862c-480e-bff8-3da6871e0b04",
                                        userArgs: {
                                          path: [
                                            $ctx.SupabaseUser.user.id,
                                            $state.upload3.files[0].name
                                          ],
                                          content: [
                                            $state.upload3.files[0].contents
                                          ],
                                          contentType: [
                                            $state.upload3.files[0].type
                                          ],
                                          upsert: [true]
                                        },
                                        cacheKey: null,
                                        invalidatedKeys: [
                                          "plasmic_refresh_all"
                                        ],
                                        roleId: null
                                      }
                                    };
                                    return (async ({
                                      dataOp,
                                      continueOnError
                                    }) => {
                                      try {
                                        const response =
                                          await executePlasmicDataOp(dataOp, {
                                            userAuthToken:
                                              dataSourcesCtx?.userAuthToken,
                                            user: dataSourcesCtx?.user
                                          });
                                        await plasmicInvalidate(
                                          dataOp.invalidatedKeys
                                        );
                                        return response;
                                      } catch (e) {
                                        if (!continueOnError) {
                                          throw e;
                                        }
                                        return e;
                                      }
                                    })?.apply(null, [actionArgs]);
                                  })()
                                : undefined;
                              if (
                                $steps["supabaseUploadFile"] != null &&
                                typeof $steps["supabaseUploadFile"] ===
                                  "object" &&
                                typeof $steps["supabaseUploadFile"].then ===
                                  "function"
                              ) {
                                $steps["supabaseUploadFile"] = await $steps[
                                  "supabaseUploadFile"
                                ];
                              }

                              $steps["postgresUpdateById"] = true
                                ? (() => {
                                    const actionArgs = {
                                      dataOp: {
                                        sourceId: "kVSSe8ab4TtzwRPnTeEeUp",
                                        opId: "1d316c45-4c3c-4fdb-88bb-e87b178387e4",
                                        userArgs: {
                                          keys: [$ctx.SupabaseUser.user.id],
                                          variables: [
                                            $steps.supabaseUploadFile?.path.split(
                                              "/"
                                            )[1],
                                            (() => {})()
                                          ]
                                        },
                                        cacheKey: null,
                                        invalidatedKeys: [
                                          "plasmic_refresh_all"
                                        ],
                                        roleId: null
                                      }
                                    };
                                    return (async ({
                                      dataOp,
                                      continueOnError
                                    }) => {
                                      try {
                                        const response =
                                          await executePlasmicDataOp(dataOp, {
                                            userAuthToken:
                                              dataSourcesCtx?.userAuthToken,
                                            user: dataSourcesCtx?.user
                                          });
                                        await plasmicInvalidate(
                                          dataOp.invalidatedKeys
                                        );
                                        return response;
                                      } catch (e) {
                                        if (!continueOnError) {
                                          throw e;
                                        }
                                        return e;
                                      }
                                    })?.apply(null, [actionArgs]);
                                  })()
                                : undefined;
                              if (
                                $steps["postgresUpdateById"] != null &&
                                typeof $steps["postgresUpdateById"] ===
                                  "object" &&
                                typeof $steps["postgresUpdateById"].then ===
                                  "function"
                              ) {
                                $steps["postgresUpdateById"] = await $steps[
                                  "postgresUpdateById"
                                ];
                              }
                            }}
                            showUploadList={false}
                          >
                            <div
                              className={classNames(
                                projectcss.all,
                                sty.freeBox__nhjbP
                              )}
                            >
                              <Stack__
                                as={PlasmicImg__}
                                hasGap={true}
                                alt={""}
                                className={classNames(sty.img__slg9T)}
                                displayHeight={"39px"}
                                displayMaxHeight={"none"}
                                displayMaxWidth={"100%"}
                                displayMinHeight={"0"}
                                displayMinWidth={"0"}
                                displayWidth={"39px"}
                                loading={"lazy"}
                                src={{
                                  src: "/plasmic/jam_production_ðŸš€/images/frame1437254220.svg",
                                  fullWidth: 39,
                                  fullHeight: 39,
                                  aspectRatio: 1
                                }}
                              />

                              <div
                                className={classNames(
                                  projectcss.all,
                                  projectcss.__wab_text,
                                  sty.text__cazK
                                )}
                              >
                                {"Importer ou d\u00e9poser un fichier"}
                              </div>
                              <div
                                className={classNames(
                                  projectcss.all,
                                  projectcss.__wab_text,
                                  sty.text__znRod
                                )}
                              >
                                {"PDF, DOC, DOCX, JPG (max. 2Mo)"}
                              </div>
                            </div>
                          </UploadWrapper>
                        </FormItemWrapper>
                      </Stack__>
                      <div
                        className={classNames(
                          projectcss.all,
                          sty.freeBox___2I8Bb
                        )}
                      >
                        <Button
                          className={classNames(
                            "__wab_instance",
                            sty.button__cYaxa
                          )}
                          end={
                            <GroupIcon
                              className={classNames(
                                projectcss.all,
                                sty.svg__oeBx
                              )}
                              role={"img"}
                            />
                          }
                          iconEnd={true}
                          label={
                            <div
                              className={classNames(
                                projectcss.all,
                                projectcss.__wab_text,
                                sty.text__mOKsv
                              )}
                            >
                              {"COntinuer"}
                            </div>
                          }
                          onClick={async event => {
                            const $steps = {};

                            $steps["updateStep"] = true
                              ? (() => {
                                  const actionArgs = {
                                    variable: {
                                      objRoot: $state,
                                      variablePath: ["step"]
                                    },
                                    operation: 2
                                  };
                                  return (({
                                    variable,
                                    value,
                                    startIndex,
                                    deleteCount
                                  }) => {
                                    if (!variable) {
                                      return;
                                    }
                                    const { objRoot, variablePath } = variable;

                                    const oldValue = $stateGet(
                                      objRoot,
                                      variablePath
                                    );
                                    $stateSet(
                                      objRoot,
                                      variablePath,
                                      oldValue + 1
                                    );
                                    return oldValue + 1;
                                  })?.apply(null, [actionArgs]);
                                })()
                              : undefined;
                            if (
                              $steps["updateStep"] != null &&
                              typeof $steps["updateStep"] === "object" &&
                              typeof $steps["updateStep"].then === "function"
                            ) {
                              $steps["updateStep"] = await $steps["updateStep"];
                            }
                          }}
                          submitsForm={true}
                        />
                      </div>
                    </FormWrapper>
                  );
                })()}
              </div>
              <Stack__
                as={"div"}
                hasGap={true}
                className={classNames(projectcss.all, sty.freeBox__w1Je2)}
              >
                {(_par => (!_par ? [] : Array.isArray(_par) ? _par : [_par]))(
                  (() => {
                    try {
                      return $queries.stripeProductsList.data.response.data
                        .filter(
                          recuring => recuring.default_price.recurring !== null
                        )
                        .sort((a, b) => a.name.localeCompare(b.name));
                    } catch (e) {
                      if (
                        e instanceof TypeError ||
                        e?.plasmicType === "PlasmicUndefinedDataError"
                      ) {
                        return [];
                      }
                      throw e;
                    }
                  })()
                ).map((__plasmic_item_0, __plasmic_idx_0) => {
                  const currentItem = __plasmic_item_0;
                  const currentIndex = __plasmic_idx_0;
                  return (
                    <div
                      className={classNames(
                        projectcss.all,
                        sty.freeBox___03UFy
                      )}
                      key={currentIndex}
                      onClick={async event => {
                        const $steps = {};

                        $steps["updateProductId"] = true
                          ? (() => {
                              const actionArgs = {
                                variable: {
                                  objRoot: $state,
                                  variablePath: ["productId"]
                                },
                                operation: 0,
                                value: currentItem.id
                              };
                              return (({
                                variable,
                                value,
                                startIndex,
                                deleteCount
                              }) => {
                                if (!variable) {
                                  return;
                                }
                                const { objRoot, variablePath } = variable;

                                $stateSet(objRoot, variablePath, value);
                                return value;
                              })?.apply(null, [actionArgs]);
                            })()
                          : undefined;
                        if (
                          $steps["updateProductId"] != null &&
                          typeof $steps["updateProductId"] === "object" &&
                          typeof $steps["updateProductId"].then === "function"
                        ) {
                          $steps["updateProductId"] = await $steps[
                            "updateProductId"
                          ];
                        }

                        $steps["updatePriceId"] = true
                          ? (() => {
                              const actionArgs = {
                                variable: {
                                  objRoot: $state,
                                  variablePath: ["priceId"]
                                },
                                operation: 0,
                                value:
                                  $queries.productPrice.data.response.data.find(
                                    product =>
                                      product.product === $state.productId
                                  ).id
                              };
                              return (({
                                variable,
                                value,
                                startIndex,
                                deleteCount
                              }) => {
                                if (!variable) {
                                  return;
                                }
                                const { objRoot, variablePath } = variable;

                                $stateSet(objRoot, variablePath, value);
                                return value;
                              })?.apply(null, [actionArgs]);
                            })()
                          : undefined;
                        if (
                          $steps["updatePriceId"] != null &&
                          typeof $steps["updatePriceId"] === "object" &&
                          typeof $steps["updatePriceId"].then === "function"
                        ) {
                          $steps["updatePriceId"] = await $steps[
                            "updatePriceId"
                          ];
                        }
                      }}
                    >
                      <ProductCard
                        active={undefined}
                        className={classNames(
                          "__wab_instance",
                          sty.productCard__hpEps
                        )}
                        productId={(() => {
                          try {
                            return currentItem.id;
                          } catch (e) {
                            if (
                              e instanceof TypeError ||
                              e?.plasmicType === "PlasmicUndefinedDataError"
                            ) {
                              return undefined;
                            }
                            throw e;
                          }
                        })()}
                      />
                    </div>
                  );
                })}
              </Stack__>
              <Stack__
                as={"div"}
                hasGap={true}
                className={classNames(projectcss.all, sty.freeBox__df2Vv)}
              >
                <Button
                  className={classNames("__wab_instance", sty.button__orIfP)}
                  end={
                    <GroupIcon
                      className={classNames(projectcss.all, sty.svg__fwEb)}
                      role={"img"}
                    />
                  }
                  label={
                    <div
                      className={classNames(
                        projectcss.all,
                        projectcss.__wab_text,
                        sty.text__jMbPq
                      )}
                    >
                      {"retour"}
                    </div>
                  }
                  onClick={async event => {
                    const $steps = {};

                    $steps["goStep0"] = true
                      ? (() => {
                          const actionArgs = {
                            variable: {
                              objRoot: $state,
                              variablePath: ["step"]
                            },
                            operation: 3,
                            value: 1
                          };
                          return (({
                            variable,
                            value,
                            startIndex,
                            deleteCount
                          }) => {
                            if (!variable) {
                              return;
                            }
                            const { objRoot, variablePath } = variable;

                            const oldValue = $stateGet(objRoot, variablePath);
                            $stateSet(objRoot, variablePath, oldValue - 1);
                            return oldValue - 1;
                          })?.apply(null, [actionArgs]);
                        })()
                      : undefined;
                    if (
                      $steps["goStep0"] != null &&
                      typeof $steps["goStep0"] === "object" &&
                      typeof $steps["goStep0"].then === "function"
                    ) {
                      $steps["goStep0"] = await $steps["goStep0"];
                    }
                  }}
                  submitsForm={true}
                  type={"bordered"}
                />

                <Button
                  className={classNames("__wab_instance", sty.button__qO9W)}
                  end={
                    <GroupIcon
                      className={classNames(projectcss.all, sty.svg__ifln1)}
                      role={"img"}
                    />
                  }
                  iconEnd={true}
                  label={
                    <div
                      className={classNames(
                        projectcss.all,
                        projectcss.__wab_text,
                        sty.text__soI9U
                      )}
                    >
                      {"souscrire"}
                    </div>
                  }
                  onClick={async event => {
                    const $steps = {};

                    $steps["stripeCheckoutSession"] = true
                      ? (() => {
                          const actionArgs = {
                            dataOp: {
                              sourceId: "iWyefF3oqfc9knnzuF1Fin",
                              opId: "7a3bbe72-8573-43c8-8756-40fef9354511",
                              userArgs: {
                                params: [
                                  $queries.stripeProductsList.data.response.data.find(
                                    product => product.id === $state.productId
                                  ).default_price.id,
                                  $ctx.SupabaseUser.user.email
                                ]
                              },
                              cacheKey: null,
                              invalidatedKeys: ["plasmic_refresh_all"],
                              roleId: null
                            },
                            continueOnError: false
                          };
                          return (async ({ dataOp, continueOnError }) => {
                            try {
                              const response = await executePlasmicDataOp(
                                dataOp,
                                {
                                  userAuthToken: dataSourcesCtx?.userAuthToken,
                                  user: dataSourcesCtx?.user
                                }
                              );
                              await plasmicInvalidate(dataOp.invalidatedKeys);
                              return response;
                            } catch (e) {
                              if (!continueOnError) {
                                throw e;
                              }
                              return e;
                            }
                          })?.apply(null, [actionArgs]);
                        })()
                      : undefined;
                    if (
                      $steps["stripeCheckoutSession"] != null &&
                      typeof $steps["stripeCheckoutSession"] === "object" &&
                      typeof $steps["stripeCheckoutSession"].then === "function"
                    ) {
                      $steps["stripeCheckoutSession"] = await $steps[
                        "stripeCheckoutSession"
                      ];
                    }

                    $steps["goToPage"] = true
                      ? (() => {
                          const actionArgs = {
                            destination: (() => {
                              try {
                                return $steps.stripeCheckoutSession.data
                                  .response.url;
                              } catch (e) {
                                if (
                                  e instanceof TypeError ||
                                  e?.plasmicType === "PlasmicUndefinedDataError"
                                ) {
                                  return undefined;
                                }
                                throw e;
                              }
                            })()
                          };
                          return (({ destination }) => {
                            if (
                              typeof destination === "string" &&
                              destination.startsWith("#")
                            ) {
                              document
                                .getElementById(destination.substr(1))
                                .scrollIntoView({ behavior: "smooth" });
                            } else {
                              __nextRouter?.push(destination);
                            }
                          })?.apply(null, [actionArgs]);
                        })()
                      : undefined;
                    if (
                      $steps["goToPage"] != null &&
                      typeof $steps["goToPage"] === "object" &&
                      typeof $steps["goToPage"].then === "function"
                    ) {
                      $steps["goToPage"] = await $steps["goToPage"];
                    }
                  }}
                  submitsForm={true}
                />
              </Stack__>
              <Stack__
                as={"div"}
                hasGap={true}
                className={classNames(projectcss.all, sty.freeBox__sPyBj)}
              >
                <div className={classNames(projectcss.all, sty.freeBox__mBMuV)}>
                  <Icon12Icon
                    className={classNames(projectcss.all, sty.svg__zj7Ts)}
                    onClick={async event => {
                      const $steps = {};

                      $steps["postgresUpdateMany"] = true
                        ? (() => {
                            const actionArgs = {
                              dataOp: {
                                sourceId: "kVSSe8ab4TtzwRPnTeEeUp",
                                opId: "e205d484-80c7-4de7-b5c0-7d0135a1a283",
                                userArgs: {
                                  conditions: [$ctx.SupabaseUser.user.id],
                                  variables: [null]
                                },
                                cacheKey: null,
                                invalidatedKeys: ["plasmic_refresh_all"],
                                roleId: null
                              }
                            };
                            return (async ({ dataOp, continueOnError }) => {
                              try {
                                const response = await executePlasmicDataOp(
                                  dataOp,
                                  {
                                    userAuthToken:
                                      dataSourcesCtx?.userAuthToken,
                                    user: dataSourcesCtx?.user
                                  }
                                );
                                await plasmicInvalidate(dataOp.invalidatedKeys);
                                return response;
                              } catch (e) {
                                if (!continueOnError) {
                                  throw e;
                                }
                                return e;
                              }
                            })?.apply(null, [actionArgs]);
                          })()
                        : undefined;
                      if (
                        $steps["postgresUpdateMany"] != null &&
                        typeof $steps["postgresUpdateMany"] === "object" &&
                        typeof $steps["postgresUpdateMany"].then === "function"
                      ) {
                        $steps["postgresUpdateMany"] = await $steps[
                          "postgresUpdateMany"
                        ];
                      }
                    }}
                    role={"img"}
                  />
                </div>
                <div
                  className={classNames(
                    projectcss.all,
                    projectcss.__wab_text,
                    sty.text__aB2F
                  )}
                >
                  {"Votre profil a bien \u00e9t\u00e9 cr\u00e9e."}
                </div>
                <div className={classNames(projectcss.all, sty.freeBox__w3X56)}>
                  <Button
                    className={classNames("__wab_instance", sty.button__so7UN)}
                    end={
                      <GroupIcon
                        className={classNames(projectcss.all, sty.svg__glab)}
                        role={"img"}
                      />
                    }
                    iconEnd={true}
                    label={
                      <div
                        className={classNames(
                          projectcss.all,
                          projectcss.__wab_text,
                          sty.text__ghgwu
                        )}
                      >
                        {'publier une offre d"emploi'}
                      </div>
                    }
                  />
                </div>
              </Stack__>
              <AlertManager
                alerts={["Paiement annul\u00e9"]}
                className={
                  "error" +
                  " " +
                  classNames("__wab_instance", sty.alertManager___6Pabv)
                }
                maxAlerts={3}
                position={"inline"}
              />

              <AlertManager
                alerts={["Paiement effectu\u00e9 avec succ\u00e8s"]}
                className={
                  "success" +
                  " " +
                  classNames("__wab_instance", sty.alertManager__lhaCy)
                }
                maxAlerts={3}
                position={"inline"}
              />

              <ProgressBar
                className={classNames(
                  "__wab_instance",
                  sty.progressBar___7XbKn
                )}
                step1={(() => {
                  try {
                    return $state.step >= 0;
                  } catch (e) {
                    if (
                      e instanceof TypeError ||
                      e?.plasmicType === "PlasmicUndefinedDataError"
                    ) {
                      return [];
                    }
                    throw e;
                  }
                })()}
                step2={(() => {
                  try {
                    return $state.step >= 1;
                  } catch (e) {
                    if (
                      e instanceof TypeError ||
                      e?.plasmicType === "PlasmicUndefinedDataError"
                    ) {
                      return [];
                    }
                    throw e;
                  }
                })()}
                step3={(() => {
                  try {
                    return $state.step === 2;
                  } catch (e) {
                    if (
                      e instanceof TypeError ||
                      e?.plasmicType === "PlasmicUndefinedDataError"
                    ) {
                      return [];
                    }
                    throw e;
                  }
                })()}
              />
            </Stack__>
          </React.Fragment>
        ),
        value: args.children
      })}
    </div>
  ) as React.ReactElement | null;
}

const PlasmicDescendants = {
  root: ["root"]
} as const;
type NodeNameType = keyof typeof PlasmicDescendants;
type DescendantsType<T extends NodeNameType> =
  (typeof PlasmicDescendants)[T][number];
type NodeDefaultElementType = {
  root: "div";
};

type ReservedPropsType = "variants" | "args" | "overrides";
type NodeOverridesType<T extends NodeNameType> = Pick<
  PlasmicOnboarding__OverridesType,
  DescendantsType<T>
>;
type NodeComponentProps<T extends NodeNameType> =
  // Explicitly specify variants, args, and overrides as objects
  {
    variants?: PlasmicOnboarding__VariantsArgs;
    args?: PlasmicOnboarding__ArgsType;
    overrides?: NodeOverridesType<T>;
  } & Omit<PlasmicOnboarding__VariantsArgs, ReservedPropsType> & // Specify variants directly as props
    // Specify args directly as props
    Omit<PlasmicOnboarding__ArgsType, ReservedPropsType> &
    // Specify overrides for each element directly as props
    Omit<
      NodeOverridesType<T>,
      ReservedPropsType | VariantPropType | ArgPropType
    > &
    // Specify props for the root element
    Omit<
      Partial<React.ComponentProps<NodeDefaultElementType[T]>>,
      ReservedPropsType | VariantPropType | ArgPropType | DescendantsType<T>
    >;

function makeNodeComponent<NodeName extends NodeNameType>(nodeName: NodeName) {
  type PropsType = NodeComponentProps<NodeName> & { key?: React.Key };
  const func = function <T extends PropsType>(
    props: T & StrictProps<T, PropsType>
  ) {
    const { variants, args, overrides } = React.useMemo(
      () =>
        deriveRenderOpts(props, {
          name: nodeName,
          descendantNames: PlasmicDescendants[nodeName],
          internalArgPropNames: PlasmicOnboarding__ArgProps,
          internalVariantPropNames: PlasmicOnboarding__VariantProps
        }),
      [props, nodeName]
    );
    return PlasmicOnboarding__RenderFunc({
      variants,
      args,
      overrides,
      forNode: nodeName
    });
  };
  if (nodeName === "root") {
    func.displayName = "PlasmicOnboarding";
  } else {
    func.displayName = `PlasmicOnboarding.${nodeName}`;
  }
  return func;
}

export const PlasmicOnboarding = Object.assign(
  // Top-level PlasmicOnboarding renders the root element
  makeNodeComponent("root"),
  {
    // Helper components rendering sub-elements

    // Metadata about props expected for PlasmicOnboarding
    internalVariantProps: PlasmicOnboarding__VariantProps,
    internalArgProps: PlasmicOnboarding__ArgProps
  }
);

export default PlasmicOnboarding;
/* prettier-ignore-end */
